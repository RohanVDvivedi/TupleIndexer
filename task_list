** PICKED TASKS

* heap_table
 * this module will provides api to work with heap_pages
 * it is essentially a bplus_tree of all the heap pages for a particular table
 * does not keep track of wha pages have free space in them, you need to keep external data structures for that
 * simple api as below
   * persistent_page acquire_heap_page(uint64_t root_page_id, int check_presence, int lock_type, uint64_t page_id ... );
     * if check_presence == 1, then the function would ensure that it exists in the heap_table's bplus_tree, returns NULL if it does not exists
     * if page_id == NULL_PAGE_ID, then a new page is allocated and that is inserted in the heap_table's bplus_tree and is returned
     * else the exact same page_id is locked and returned
   * int release_heap_page(uint64_t root_page_id, int lock_type, persistent_page ppage ... );
     * if pmm is NULL, release lock and exit, else
     * check if the page is empty, and set an is_empty flag
     * release lock on the page
     * scan the heap_table's bplus_tree to see that it exists
     * make sure it is still empty,
     * if empty, free the page, and remove its entry from the heap_table's bplus_tree and exit
     * returns 1 if the page was freed and its entry removed
 * api of persistent page has to be exposed
 * need scan, an iterator over the heap_table's bplus_tree
   * start at or after a predefined page_id
   * every next call returns a page_id
   * get_curr_page_id -> returns current page id
   * persistent_page acquire_heap_page(int lock_type) -> acquires page with the current page id -> very simple logic
   * release_heap_page(persistent_page ppage) -> does the same logic as discussed above but with the iterator locked on the corresponding page, must ensure that ppage is the current page
 * scan can be used for vaccumming, sequential scan of the table or to precompute a free space map of the table
 * how much free space each page has is not maintained by the data structure and you need to maintain that for efficient rows layout
 * since all pages are maintained as a sorted set of pages, scanning them will never reseult in double encounter with a page


** OTHER DATABASE DATASTRUCTURE TASKS (VERY IMPORTANT FOR FUTURE OF PROJECT)
 * Rtree will be supported
   * very similar to b+tree, n dimensional data can be searched, inserted, deleted, no least_keys_page_id required
   * splits and merges happen according to the minimal increase in interior node areas
   * inserts walk down only 1 path of the tree, trying to minimize the increased area
   * searches walk down a tree, and maintain a stack, releasing locks only if only 1 entry is to be scaned in the interior node, in READ_LOCK
     * next, prev and get_curr are always supported, in WRITE_LOCK and READ_LOCK_INTERIOR_WRITE_LOCK_LEAF deletes and inserts (if we are in right rectangle), updates are supported
   * you need to define a rtree_tuple_definitions, that also has a function pointer to get the hyper_rectangle for any of the records (which is provided by the user)
   * hyper rectangle is an n dimensional rectangle.
   * all interior nodes store a hyper rectangle and a corresponding page_id, and atleast 2 entries must fit on a page, else rttd contruction fails. yet you can have any number of dimensions.
   * you can also specify any numeral datatype for dimension, as long as it is supported by the TupleStore.
   * need to think about how to calculate areas of the hyper rectangle with dimensions of different types, such that it fits a number and also does not violate precision requirements (getting areas is necessary for splitting and merging).
   * fail insertions if the lower_bound and upper_bound of the get_hyper_rectangle do not follow <= comparison for any of the n dimensions.
   * build utility function to check that hyper rectangle does not have a negative dimension (i.e. lower_bound <= upper_bound), construct hyper_rectangle covering 2 or more hyper rectangles, and check if a hyper_rectangle intersects with another hyper_rectangle etc.
   * accomodate any tuple that is atleast half the size of the leaf page, and interior page tuples would be fixed width with non NULL elements
   * keys will have a even count and all of numeral types, for ith dimension lower bound would be 2*i th key element and 2*i+1 will be upper bound, up to d dimentions (0 <= i < 2*d).
 * build functions to relocate root of the datastructures to lower page ids

FAR FUTURE TASKS AND CONCEPTS
  * implement borrow_from_left and borrow_from_right functions for interior pages and leaf pages to be performed while merges
   * this will be implemented for variable length keys aswell
   * this will take parent page, left page and right page as input and will perform a borrow to make left and right pages balanced if it is possible by the use of borrowing
   * since this function will also modify the parent page, do relese lock on the parent page also if this operation succeeds
   * these functions will be called inside the merge_and unlock_pages_up right before we attempt to merge
   * if the borrowing succeeds we can directly release locks on all the three pages, pop the parent from the locked pages stack and break out of this loop
 * OPTIMIZATION in suffix truncation :: handle cases if INT, UINT, LARGE_UINT, BIT_FIELD, in loop 1, if unequal on ASC-> then set element to last_tuple_page1 element + 1 (to min element if NULL), if unequal on DESC-> then set element to last_tuple_page1 element - 1, if the last_tuple_page1_element is not the min value, else set it to NULL
