** PICKED TASKS

 * heap_page
  * in get_unused_space from heap page, if the tombstone count > 0, then there is 1 additional_space_overhead bytes of extra space on it
  * uint32_t insert_in_heap_page(persistent_page* ppage, const void* tuple, uint32_t* possible_insertion_index);
    * checks tuple is not NULL only then inserts
    * return value is the index where this function call inserted the tuple
    * (*possible_insertion_index) will always be set to the value to insert the next tuple, so preserve it and pass between runs
    * possible_insertion_index if NULL starts the checks from 0
  * int delete_from_heap_page(persistent_page* ppage, uint32_t index);
    * fails if a tuple does not exist at the index
    * updates the tuple to NULL in the page at that index

 * heap_table
  * persistent_page get_heap_page_with_enough_unused_space_from_heap_table(uint64_t root_page_id, uint32_t unused_space, callback_wrong_entry)
  * test cases and test

** OTHER DATABASE DATASTRUCTURE TASKS (VERY IMPORTANT FOR FUTURE OF PROJECT)
 * Rtree will be supported
   * very similar to b+tree, n dimensional data can be searched, inserted, deleted, no least_keys_page_id required
   * splits and merges happen according to the minimal increase in interior node areas
   * inserts walk down only 1 path of the tree, trying to minimize the increased area
   * searches walk down a tree, and maintain a stack, releasing locks only if only 1 entry is to be scaned in the interior node, in READ_LOCK
     * next, prev and get_curr are always supported, in WRITE_LOCK and READ_LOCK_INTERIOR_WRITE_LOCK_LEAF deletes and inserts (if we are in right rectangle), updates are supported
   * you need to define a rtree_tuple_definitions, that also has a function pointer to get the hyper_rectangle for any of the records (which is provided by the user)
   * hyper rectangle is an n dimensional rectangle.
   * all interior nodes store a hyper rectangle and a corresponding page_id, and atleast 2 entries must fit on a page, else rttd contruction fails. yet you can have any number of dimensions.
   * you can also specify any numeral datatype for dimension, as long as it is supported by the TupleStore.
   * need to think about how to calculate areas of the hyper rectangle with dimensions of different types, such that it fits a number and also does not violate precision requirements (getting areas is necessary for splitting and merging).
   * fail insertions if the lower_bound and upper_bound of the get_hyper_rectangle do not follow <= comparison for any of the n dimensions.
   * build utility function to check that hyper rectangle does not have a negative dimension (i.e. lower_bound <= upper_bound), construct hyper_rectangle covering 2 or more hyper rectangles, and check if a hyper_rectangle intersects with another hyper_rectangle etc.
   * accomodate any tuple that is atleast half the size of the leaf page, and interior page tuples would be fixed width with non NULL elements
   * keys will have a even count and all of numeral types, for ith dimension lower bound would be 2*i th key element and 2*i+1 will be upper bound, up to d dimentions (0 <= i < 2*d).
 * build functions to relocate root of the datastructures to lower page ids

FAR FUTURE TASKS AND CONCEPTS
  * implement borrow_from_left and borrow_from_right functions for interior pages and leaf pages to be performed while merges
   * this will be implemented for variable length keys aswell
   * this will take parent page, left page and right page as input and will perform a borrow to make left and right pages balanced if it is possible by the use of borrowing
   * since this function will also modify the parent page, do relese lock on the parent page also if this operation succeeds
   * these functions will be called inside the merge_and unlock_pages_up right before we attempt to merge
   * if the borrowing succeeds we can directly release locks on all the three pages, pop the parent from the locked pages stack and break out of this loop
 * OPTIMIZATION in suffix truncation :: handle cases if INT, UINT, LARGE_UINT, BIT_FIELD, in loop 1, if unequal on ASC-> then set element to last_tuple_page1 element + 1 (to min element if NULL), if unequal on DESC-> then set element to last_tuple_page1 element - 1, if the last_tuple_page1_element is not the min value, else set it to NULL
