** PICKED TASKS

 * heap_table
  * a b+tree storing only (unused_space, page_id)
  * allows to easily find a heap_page that has enough unused_space on some heap_page that can accomodate an incomming tuple
  * for regular operation you may also use unused_space in the heap_table as a hint and update it less frequently and in bursts at regular intervals
  * unused_space = get_space_allotted_to_all_tuples_on_persistent_page(ppage, page_size, tpl_sz_d) - get_space_occupied_by_all_tuples_on_persistent_page(ppage, page_size, tpl_sz_d);
  * api
    * no new page header files necessary
    * heap_table_tuple_defs
      * stores in a pas_p and a bplus_tree_tuple_defs for (unused_space -> pas_p->page_offset_type_info, page_id -> pas_p->page_id_type_info)
      * and finally tuple_def for the heap_page tuples
    * static functions
      * get_new_heap_table() -> return a bplus_tree
      * delete_heap_table() -> delete all the heap_pages and then the bplus_tree
      * print_heap_table() -> iterate over all entries, print all entries and heap_pages
      * fix_heap_page_entry_in_heap_table(uint32_t unused_space, uint64_t heap_page_id) -> fixes the unused_space for the passed entry, removes the entry and reinserts if necessary
      * track_heap_page_in_heap_table(persistent_page heap_page); -> inserts the heap_page's entry in heap_table (for the first time) and releases lock on the page
    * iterator functions
      * this will be a leaf-only read-only forward-only scan, no pmm_p to be provided here, but you can lock heap_page itself in write_locked mode if you intend to modify it
      * you may want to acquire a shared ordering lock, if you plan to access tuples in their fixed existing order, desirable by MVCC databases to void reading duplicates and missing some tuples altogether, for this you also need to take exclusive ordering lock while performing fix_heap_page_entry_in_heap_table -> add this information as a comment
      * get_new_heap_table_iterator(uint32_t unused_space, uint64_t heap_page_id) -> starts from a desired entry to search for, can also be used for a finding a enough space containing page for a new tuple
      * get_curr_unused_space_heap_table_iterator();
      * get_curr_heap_page_id_heap_table_iterator();
      * persistent_page lock_and_get_curr_heap_page_heap_table_iterator(int write_locked);
      * next_heap_table_iterator(); -> goes to the next entry
      * clone_heap_table_iterator();
      * delete_heap_table_iterator();

** OTHER DATABASE DATASTRUCTURE TASKS (VERY IMPORTANT FOR FUTURE OF PROJECT)
 * Rtree will be supported
   * very similar to b+tree, n dimensional data can be searched, inserted, deleted, no least_keys_page_id required
   * splits and merges happen according to the minimal increase in interior node areas
   * inserts walk down only 1 path of the tree, trying to minimize the increased area
   * searches walk down a tree, and maintain a stack, releasing locks only if only 1 entry is to be scaned in the interior node, in READ_LOCK
     * next, prev and get_curr are always supported, in WRITE_LOCK and READ_LOCK_INTERIOR_WRITE_LOCK_LEAF deletes and inserts (if we are in right rectangle), updates are supported
   * you need to define a rtree_tuple_definitions, that also has a function pointer to get the hyper_rectangle for any of the records (which is provided by the user)
   * hyper rectangle is an n dimensional rectangle.
   * all interior nodes store a hyper rectangle and a corresponding page_id, and atleast 2 entries must fit on a page, else rttd contruction fails. yet you can have any number of dimensions.
   * you can also specify any numeral datatype for dimension, as long as it is supported by the TupleStore.
   * need to think about how to calculate areas of the hyper rectangle with dimensions of different types, such that it fits a number and also does not violate precision requirements (getting areas is necessary for splitting and merging).
   * fail insertions if the lower_bound and upper_bound of the get_hyper_rectangle do not follow <= comparison for any of the n dimensions.
   * build utility function to check that hyper rectangle does not have a negative dimension (i.e. lower_bound <= upper_bound), construct hyper_rectangle covering 2 or more hyper rectangles, and check if a hyper_rectangle intersects with another hyper_rectangle etc.
   * accomodate any tuple that is atleast half the size of the leaf page, and interior page tuples would be fixed width with non NULL elements
   * keys will have a even count and all of numeral types, for ith dimension lower bound would be 2*i th key element and 2*i+1 will be upper bound, up to d dimentions (0 <= i < 2*d).
 * build functions to relocate root of the datastructures to lower page ids

FAR FUTURE TASKS AND CONCEPTS
  * implement borrow_from_left and borrow_from_right functions for interior pages and leaf pages to be performed while merges
   * this will be implemented for variable length keys aswell
   * this will take parent page, left page and right page as input and will perform a borrow to make left and right pages balanced if it is possible by the use of borrowing
   * since this function will also modify the parent page, do relese lock on the parent page also if this operation succeeds
   * these functions will be called inside the merge_and unlock_pages_up right before we attempt to merge
   * if the borrowing succeeds we can directly release locks on all the three pages, pop the parent from the locked pages stack and break out of this loop
 * OPTIMIZATION in suffix truncation :: handle cases if INT, UINT, LARGE_UINT, BIT_FIELD, in loop 1, if unequal on ASC-> then set element to last_tuple_page1 element + 1 (to min element if NULL), if unequal on DESC-> then set element to last_tuple_page1 element - 1, if the last_tuple_page1_element is not the min value, else set it to NULL
